"""Test datasets generated by Gemini 3 Thinking model."""

def generate_matching_graph(n):
    """
    Generates a Matching Graph M_n.
    - Vertices: 2n
    - Edges: n disjoint edges.
    - Biclique Dimension (k): EXACTLY n.
    - Why this is the best benchmark: It gives you perfect control over k.
      Matching 6 is instant. Matching 8 takes seconds. Matching 9 takes minutes.
    """
    edges = []
    for i in range(n):
        edges.append((i, i + n))
    return edges

def generate_half_graph(n):
    """
    Generates a Half-Graph (Triangular Matrix).
    - Structure: u_i connects to v_j if i <= j.
    - Density: ~50% (Dense).
    - Exact k: n (Boolean Rank of a triangular matrix is full).
    - Jared's Algo: Should perform MUCH better here because the
      graph naturally forms a 'staircase' shape, which his
      algorithm is designed to exploit.
    """
    edges = []
    for u in range(n):
        for v in range(n):
            # Connect if row index <= col index (Upper Triangle)
            if u <= v:
                edges.append((u, v + n))
    return edges

# --- The Final Benchmark Dictionary ---

TEST_DATA = {
    # 1. EASY: Matching 6 (Target k=6)
    # The Baseline.
    # Your exact solver should solve this in < 0.1 seconds.
    "Easy_Matching_6": generate_matching_graph(6),

    # 2. MEDIUM: Matching 8 (Target k=8)
    # The Sweet Spot.
    # This forces the solver to verify UNSAT for k=1..7.
    # Expect 5-60 seconds depending on CPU.
    "Medium_Matching_8": generate_matching_graph(8),

    # 3. HARD: Dense Half-Graph 9 (Exact k=9)
    # DENSE.
    # Exact Solver: Will struggle (k=9 is high).
    # Jared's Solver: Should finally return a respectable k (likely > 4),
    # proving his algorithm works better on dense data.
    "Hard_Dense_Half_9": generate_half_graph(10)
}

if __name__ == "__main__":
    for name, edges in TEST_DATA.items():
        print(f"Dataset '{name}': {len(edges)} edges")